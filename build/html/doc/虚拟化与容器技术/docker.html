

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="zh-CN" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="zh-CN" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>1. Docker &mdash; Hang&#39;s Tec Room 1.0 文档</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript">
          var DOCUMENTATION_OPTIONS = {
              URL_ROOT:'../../',
              VERSION:'1.0',
              LANGUAGE:'zh_CN',
              COLLAPSE_INDEX:false,
              FILE_SUFFIX:'.html',
              HAS_SOURCE:  true,
              SOURCELINK_SUFFIX: '.txt'
          };
      </script>
        <script type="text/javascript" src="../../_static/jquery.js"></script>
        <script type="text/javascript" src="../../_static/underscore.js"></script>
        <script type="text/javascript" src="../../_static/doctools.js"></script>
        <script type="text/javascript" src="../../_static/translations.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <link rel="index" title="索引" href="../../genindex.html" />
    <link rel="search" title="搜索" href="../../search.html" />
    <link rel="next" title="2. Kubernetes（K8S）" href="k8s.html" />
    <link rel="prev" title="1. MySQL" href="../数据库系列/mysql.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../../index.html" class="icon icon-home"> Hang's Tec Room
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">关于Room</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../关于/about_me.html">关于我</a></li>
<li class="toctree-l1"><a class="reference internal" href="../关于/about_blog.html">我的技术屋</a></li>
</ul>
<p class="caption"><span class="caption-text">编程语言及开发框架</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../编程语言及开发框架/C++.html">1. C++</a></li>
<li class="toctree-l1"><a class="reference internal" href="../编程语言及开发框架/Java技术栈/Java.html">2. Java</a></li>
<li class="toctree-l1"><a class="reference internal" href="../编程语言及开发框架/python技术栈/Python.html">3. python</a></li>
<li class="toctree-l1"><a class="reference internal" href="../编程语言及开发框架/python技术栈/django.html">4. Django</a></li>
<li class="toctree-l1"><a class="reference internal" href="../编程语言及开发框架/PHP.html">5. PHP</a></li>
<li class="toctree-l1"><a class="reference internal" href="../编程语言及开发框架/Matlab.html">6. Matlab</a></li>
</ul>
<p class="caption"><span class="caption-text">数据结构与算法系列</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../数据结构与算法系列/dataStruct_algorithm.html">1. 数据结构与算法系列</a></li>
</ul>
<p class="caption"><span class="caption-text">设计模式</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../设计模式/design-pattern.html">1. 设计模式</a></li>
</ul>
<p class="caption"><span class="caption-text">计算机网络技术</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../计算机网络技术/computer-network.html">1. 计算机网络系列</a></li>
</ul>
<p class="caption"><span class="caption-text">数据库系列</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../数据库系列/mysql.html">1. MySQL</a></li>
</ul>
<p class="caption"><span class="caption-text">虚拟化与容器技术</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">1. Docker</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#id1">1.1. 书籍推荐</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id4">1.2. 初识Docker</a></li>
<li class="toctree-l2"><a class="reference internal" href="#id5">1.3. Docker架构（组件）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id6">1.3.1. 基本架构图</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id7">1.3.2. 核心组件</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id8">1.3.3. 通过Docker开发和部署的流程图</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#docker-mac">1.4. 安装Docker（MAC)并注册国内镜像加速器</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id9">1.4.1. 安装</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id11">1.4.2. 配置阿里云镜像加速器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id13">1.5. Docker常用命令</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#docker-daemon">1.5.1. Docker服务（Daemon）相关命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#docker-image">1.5.2. Docker镜像（Image）相关命令</a></li>
<li class="toctree-l3"><a class="reference internal" href="#docker-container">1.5.3. docker容器（container）相关命令</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id15">1.6. Docker容器的数据卷</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id16">1.6.1. 概念及作用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id17">1.6.1.1. 概念</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id18">1.6.1.2. 作用</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id19">1.6.2. 配置数据卷</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id20">1.6.3. 配置 数据卷容器</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id21">1.7. Docker使用案例（应用部署实战）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#mysql">1.7.1. MySQL部署</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tomcat">1.7.2. Tomcat部署</a></li>
<li class="toctree-l3"><a class="reference internal" href="#nginx">1.7.3. Nginx部署</a></li>
<li class="toctree-l3"><a class="reference internal" href="#redis-key-value">1.7.4. Redis部署（一个key-value存储系统）</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#dockerfile">1.8. 使用Dockerfile制作镜像</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id22">1.8.1. 镜像原理</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id23">1.8.2. Dockerfile的概念和作用</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id24">1.8.2.1. 镜像制作方法</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#id25">1.8.3. 案例</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#id26">1.8.3.1. 案例一</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id27">1.8.3.2. 案例二</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#docker-compose">1.9. docker-compose（服务编排技术）</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id28">1.9.1. 服务编排概念</a></li>
<li class="toctree-l3"><a class="reference internal" href="#id29">1.9.2. 实例</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#id30">1.10. 搭建私有仓库</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="k8s.html">2. Kubernetes（K8S）</a></li>
</ul>
<p class="caption"><span class="caption-text">服务器</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../服务器/server.html">1. 服务器系列</a></li>
</ul>
<p class="caption"><span class="caption-text">分布式与微服务系列</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../分布式与微服务系列/distributeMicroServer.html">1. 分布式与微服务系列</a></li>
</ul>
<p class="caption"><span class="caption-text">机器智能系列</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/ml.html">1. 机器学习基础</a></li>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/ml.html#id3">2. 机器学习应用</a></li>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/dl.html">3. 深度学习</a></li>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/nlp.html">4. 自然语言理解</a></li>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/kg.html">5. 知识图谱</a></li>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/框架/pytorch.html">6. Pytorch</a></li>
<li class="toctree-l1"><a class="reference internal" href="../机器智能系列/框架/tensorflow.html">7. Tensorflow</a></li>
</ul>
<p class="caption"><span class="caption-text">开源工具</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../开源工具/open_source.html">1. 优秀开源工具</a></li>
</ul>
<p class="caption"><span class="caption-text">团队与项目管理</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../团队与项目管理/team_project.html">1. 团队与项目管理</a></li>
</ul>
<p class="caption"><span class="caption-text">道与术</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../道与术/tao-art.html">1. coding的道与术</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Hang's Tec Room</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
      <li>1. Docker</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/doc/虚拟化与容器技术/docker.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="docker">
<h1>1. Docker<a class="headerlink" href="#docker" title="永久链接至标题">¶</a></h1>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">更新日期：2020-03-16</p>
</div>
<div class="section" id="id1">
<h2>1.1. 书籍推荐<a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>访问 <a class="reference external" href="https://www.gitbook.com/download/pdf/book/yeasy/docker_practice">docker_practice</a> 下载。</li>
<li>《Docker开发实践》</li>
<li><dl class="first docutils">
<dt>其他</dt>
<dd><ul class="first last">
<li>访问 <a class="reference external" href="https://www.runoob.com/docker/docker-tutorial.html">菜鸟教程</a> 查看。</li>
<li>访问Docker <a class="reference external" href="https://developer.aliyun.com/article/40494?spm=5176.12281978.0.0.377241271ZQV6s">学习路线图</a> 。</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id4">
<h2>1.2. 初识Docker<a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">总的来说，Docker属于运维部署领域。如果是应用者就是熟练的在合适的场景下操作相应的命令；如果是进一步研究其底层原理，那需要的基础就要多些了，比如虚拟化技术。</p>
</div>
<ol class="arabic simple">
<li>Docker就是开源的容器引擎，诞生于2013年。最形象的比喻就是集装箱，各自自成体系，互不影响，可任意放在不同的平台。</li>
<li>Docker是容器的一种，容器是一种*轻量级(占用空间小）的虚拟技术*，相对应的，虚拟机（VMware、VirtualBox等）就是重量级的虚拟技术。</li>
<li>Docker是虚拟化的是操作系统，而虚拟机虚拟化的是硬件。</li>
<li><dl class="first docutils">
<dt>最切实的价值是什么？</dt>
<dd><ul class="first last">
<li>项目开发有三大基础环境： 开发环境（程序员）、测试环境（测试人员）、生产环境（运维人员）。</li>
<li>要保持三者环境的统一Docker的优势不明觉厉。举个例子，小王，程序员一枚，在自己电脑上优雅的完成了业务开发。怀着如释重负的心情将代码推送至测试环境，然后休息，进行吃鸡游戏……。突然，测试人员小李发来消息，小王呀，你昨天推的代码不work呀，小王说：不可能！我本地非常work的，你再仔细看看吧……；小李说：我这真没问题。</li>
<li>你看看是不是吃鸡的心情不好了！问题究竟在哪里呢？原来呀小王本地开发环境使用的Python3.7，但是小李所用的测试环境是Python3.6，造成了有些功能不work。如果我们有了Docker，就可以代码+环境保持一致，不再造成上面的尴尬！</li>
</ul>
</dd>
</dl>
</li>
<li>可移植。MAC、Win、Linux等平台。</li>
<li>相互隔离。</li>
<li>开销低。</li>
</ol>
<p><em>Docker是一种容器技术，解决软件跨环境迁移的问题！</em></p>
</div>
<div class="section" id="id5">
<h2>1.3. Docker架构（组件）<a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p class="last">Docker采用C/S架构。Docker客户端（Client）可以通过命令行形式或API来与提供Docker服务（Server）的守护进程进行通信。</p>
</div>
<div class="section" id="id6">
<h3>1.3.1. 基本架构图<a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<a class="reference internal image-reference" href="../../_images/2020-03-06-docker架构.png"><img alt="../../_images/2020-03-06-docker架构.png" src="../../_images/2020-03-06-docker架构.png" style="width: 600px;" /></a>
</div>
<div class="section" id="id7">
<h3>1.3.2. 核心组件<a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h3>
<div class="admonition important">
<p class="first admonition-title">重要</p>
<p class="last">Docker共包含三大核心组件：<strong>镜像（image）、容器（container）、仓库（Repository）</strong>。镜像和容器可以类比面向对象编程中类和实例的关系，image-&gt;class、container-&gt;instance。仓库可类别代码控制中心，负责存储和共享用户的镜像。</p>
</div>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>Image</dt>
<dd><ul class="first last">
<li>一个只读的静态模板。存储容器所需要的环境和应用的执行代码。相当于是一个root文件系统，比如官方镜像Python:3.9就包含了完整的一套Python3.9最小系统的root文件系统。</li>
<li>采用分层机制。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Container</dt>
<dd><ul class="first last">
<li>一个运行时的环境。镜像是静态的定义，容器是镜像运行时的实体。</li>
<li>容器就相当于集装箱，不关心里面装什么，所有应用都有统一的生命周期：创建、启动、删除、暂停、重启等。</li>
<li>容器也不在乎自己所处的平台。本机、虚拟机、服务器等都可相互移植，对于前面提到的部署都是非常适合的。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Repository</dt>
<dd><ul class="first last">
<li>Docker采用注册服务器来存储和共享用户的镜像。</li>
<li>注册服务器分为公共和私有两种。公共就是官方的Docker Hub，私有就是自己注册一个Docker Hub账号建立自己的私有仓库，便于小范围内的共享。</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="id8">
<h3>1.3.3. 通过Docker开发和部署的流程图<a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">利用下图能更好的理解Docker在日常开发、部署中的应用流程和三大组件。</p>
</div>
<a class="reference internal image-reference" href="../../_images/docker-开发部署流程图.png"><img alt="../../_images/docker-开发部署流程图.png" src="../../_images/docker-开发部署流程图.png" style="width: 700px;" /></a>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">流程概述:</th><td class="field-body"></td>
</tr>
</tbody>
</table>
<ul>
<li><dl class="first docutils">
<dt>开发主机上</dt>
<dd><ol class="first arabic simple">
<li>创建容器A，创建方法可以手动也可通过Dockerfile文件自动构建。</li>
</ol>
<div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">Dockerfile文件后续会讲，这也是最常用的一种构建容器方式。</p>
</div>
<ol class="last arabic simple" start="2">
<li>容器A必须基于镜像来创建。镜像A就是容器的静态形式，容器是镜像的动态形式。</li>
<li>将容器A保存为镜像A，然后推送到Docker库进行共享</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>集群环境上</dt>
<dd><ol class="first last arabic simple">
<li>在Docker库中搜索所需镜像A，并将其拉取到本地。</li>
<li>拉取后在本地就可以运行容器A了。</li>
<li>在集群环境中可以运行很多容器，彼此相互独立、互不影响。</li>
</ol>
</dd>
</dl>
</li>
</ul>
</div>
</div>
<div class="section" id="docker-mac">
<h2>1.4. 安装Docker（MAC)并注册国内镜像加速器<a class="headerlink" href="#docker-mac" title="永久链接至标题">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">MAC系统可以直接安装桌面版Docker，社区版就够用了。关于镜像加速器推荐使用国内阿里云镜像加速器，配置也比较容易，配置后再使用docker镜像就比较快了。
官网下载太慢吗？推荐前往：<a class="reference external" href="http://get.daocloud.io/">http://get.daocloud.io/</a>。</p>
</div>
<div class="section" id="id9">
<h3>1.4.1. 安装<a class="headerlink" href="#id9" title="永久链接至标题">¶</a></h3>
<ol class="arabic simple">
<li>点击 <a class="reference external" href="https://hub.docker.com/editions/community/docker-ce-desktop-mac/">下载</a> docker桌面版。</li>
<li>查看docker版本，验证是否安装成功</li>
</ol>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker -v
Docker version <span class="m">19</span>.03.5, build 633a0ea
</pre></div>
</div>
</div></blockquote>
</div>
<div class="section" id="id11">
<h3>1.4.2. 配置阿里云镜像加速器<a class="headerlink" href="#id11" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">step-1:</th><td class="field-body">使用阿里云或支付宝等账号登录 <a class="reference external" href="https://cr.console.aliyun.com/cn-hangzhou/instances/mirrors">阿里云镜像加速器</a> 网站。</td>
</tr>
<tr class="field-even field"><th class="field-name">step-2:</th><td class="field-body">登录后就能看到针对不同操作系统的操作步骤了。如下图所示：</td>
</tr>
</tbody>
</table>
<a class="reference internal image-reference" href="../../_images/2020-03-06阿里云镜像加速器.jpg"><img alt="../../_images/2020-03-06阿里云镜像加速器.jpg" src="../../_images/2020-03-06阿里云镜像加速器.jpg" style="width: 700px;" /></a>
</div></blockquote>
</div>
</div>
<div class="section" id="id13">
<h2>1.5. Docker常用命令<a class="headerlink" href="#id13" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">本章是docker知识的重点，基本都是命令。跟着命令敲起你的小键盘吧。</p>
</div>
<div class="section" id="docker-daemon">
<h3>1.5.1. Docker服务（Daemon）相关命令<a class="headerlink" href="#docker-daemon" title="永久链接至标题">¶</a></h3>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<p class="last">mac系统下直接点击客户端就启动了docker服务，非常简单。使用Mac系统，就可以跳过这部分内容了。
为了使本笔记不失一般性，这里使用CentOS进行相关命令演示。</p>
</div>
<p>休息一下：你们公司更倾向于选择什么操作系统作为服务器呢？centos、RH、Linux？ why? <a class="reference external" href="https://www.zhihu.com/question/19599986">知乎</a> 上有一篇帖子讨论了这个问题。</p>
<ol class="arabic">
<li><dl class="first docutils">
<dt>启动docker服务</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ systemctl start docker
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>停止docker服务</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ systemctl stop docker
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>重启docker服务</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ systemctl restart docker
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>查看docker服务状态</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ systemctl status docker
● docker.service - Docker Application Container Engine
Loaded: loaded <span class="o">(</span>/usr/lib/systemd/system/docker.service<span class="p">;</span> enabled<span class="p">;</span> vendor preset: disabled<span class="o">)</span>
Active: active <span class="o">(</span>running<span class="o">)</span> since 四 <span class="m">2019</span>-12-12 <span class="m">10</span>:06:56 CST<span class="p">;</span> <span class="m">2</span> months <span class="m">24</span> days ago
Docs: https://docs.docker.com
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>开机启动docker服务</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ systemctl <span class="nb">enable</span> docker
</pre></div>
</div>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="docker-image">
<h3>1.5.2. Docker镜像（Image）相关命令<a class="headerlink" href="#docker-image" title="永久链接至标题">¶</a></h3>
<ol class="arabic">
<li><dl class="first docutils">
<dt>查看</dt>
<dd><div class="first admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="last simple">
<li>docker images -q 查看所有镜像ID</li>
<li>docker iamges 查看所有镜像信息</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker images
REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
python              <span class="m">3</span>.8                 f88b2f81f83a        <span class="m">9</span> days ago          933MB
nginx               latest              2073e0bcb60e        <span class="m">4</span> weeks ago         127MB
ubuntu              <span class="m">14</span>.04               6e4f1fe62ff1        <span class="m">2</span> months ago        197MB
</pre></div>
</div>
<div class="last admonition note">
<p class="first admonition-title">注解</p>
<p>可以看到，执行命令后列出了已创建（可能你还没有镜像，列表就为空）的镜像。下面针对表头做一个说明。</p>
<ul class="last simple">
<li>REPOSITORY： 仓库名称</li>
<li>TAG：版本号，默认为latest</li>
<li>IMAGE ID：镜像唯一标识</li>
<li>CREATED ：创建时间</li>
<li>SIZE ：镜像所占的虚拟大小</li>
</ul>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>搜索</dt>
<dd><div class="first admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="last simple">
<li>docker search [name]</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker search mysql
NAME                              DESCRIPTION                                     STARS               OFFICIAL （是否官方）           AUTOMATED
mysql                             MySQL is a widely used, open-source relation…   <span class="m">9196</span>                <span class="o">[</span>OK<span class="o">]</span>
mariadb                           MariaDB is a community-developed fork of MyS…   <span class="m">3274</span>                <span class="o">[</span>OK<span class="o">]</span>
mysql/mysql-server                Optimized MySQL Server Docker images. Create…   <span class="m">679</span>                 <span class="o">[</span>OK<span class="o">]</span>
centos/mysql-57-centos7           MySQL <span class="m">5</span>.7 SQL database server                   <span class="m">70</span>
</pre></div>
</div>
<div class="last line-block">
<div class="line">搜索是联网进行的，列出可用的镜像。官方镜像搜索网站，可以查看下有没有自己想要的版本。</div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>拉取（下载）</dt>
<dd><div class="first admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="last simple">
<li>docker pull [name]:[tag]</li>
<li>不写tag，则默认为latest</li>
<li>访问 <a class="reference external" href="https://hub.docker.com/search?q=&amp;type=image">Docker Hub 镜像网站</a>，可以了解更多关于的版本信息。</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker pull mysql:5.6
<span class="m">5</span>.6: Pulling from library/mysql
6d28e14ab8c8: Pull <span class="nb">complete</span>
dda15103a86a: Pull <span class="nb">complete</span>
55971d75ab8c: Pull <span class="nb">complete</span>
f1d4ea32020b: Pull <span class="nb">complete</span>
61420072af91: Pull <span class="nb">complete</span>
30862a48418b: Pull <span class="nb">complete</span>
c6c2ee3a9a57: Pull <span class="nb">complete</span>
0f4efadb31df: Pull <span class="nb">complete</span>
dd931017b211: Pull <span class="nb">complete</span>
488a86083079: Pull <span class="nb">complete</span>
921d4bdabca2: Pull <span class="nb">complete</span>
Digest: sha256:a72a05bcf3914c902070765a506b1c8c17c06400258e7b574965763099dee9e1
Status: Downloaded newer image <span class="k">for</span> mysql:5.6
docker.io/library/mysql:5.6
</pre></div>
</div>
<div class="last line-block">
<div class="line">上面的拉取镜像过程就体现了分层。</div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>删除</dt>
<dd><div class="first admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>单个删除 docker rmi image-id/[name]:[tag]</dt>
<dd><ul class="first last">
<li>rmi。rm就是删除，i参数指的就是镜像。可以指定一个或多个镜像名称或者镜像的ID，多个镜像之间可以使用空格隔开。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>删除本次所有镜像: docker rmi <cite>docker images -q</cite></dt>
<dd><ul class="first last">
<li>docker images -q 列出所有镜像的ID</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker rmi c8078e
Untagged: mysql:5.6
Untagged: mysql@sha256:a72a05bcf3914c902070765a506b1c8c17c06400258e7b574965763099dee9e1
Deleted: sha256:c8078e8ab06d8dabd6c30cffb03951fa035d85f75c19a83ace29b01cb3ecd272
</pre></div>
</div>
<div class="last admonition warning">
<p class="first admonition-title">警告</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>如果不能删除成功，可能是因为这个镜像正在被容器使用。</dt>
<dd><ul class="first last">
<li>可以使用 -f参数强制删除。</li>
<li>也可以先移除正在使用该镜像的容器后再删除。</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="docker-container">
<h3>1.5.3. docker容器（container）相关命令<a class="headerlink" href="#docker-container" title="永久链接至标题">¶</a></h3>
<ol class="arabic">
<li><p class="first">查看</p>
<blockquote>
<div><div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="last simple">
<li><dl class="first docutils">
<dt>docker ps</dt>
<dd><ul class="first last">
<li>查看正在开启的容器</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>docker ps -a</dt>
<dd><ul class="first last">
<li>查看所有创建的容器列表</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES

$ docker ps -a
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                      PORTS                                         NAMES
3c7e127ff4ae        nginx:v3            <span class="s2">&quot;/bin/bash&quot;</span>              <span class="m">29</span> minutes ago      Exited <span class="o">(</span><span class="m">0</span><span class="o">)</span> <span class="m">25</span> minutes ago                                                 web_server
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">创建</p>
<blockquote>
<div><div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="last simple">
<li>docker run -i -t –name=container_name  image_name:tag  /bin/bash</li>
<li><dl class="first docutils">
<dt>docker run -i -d –name=container_name  image_name:tag  /bin/bash</dt>
<dd><ul class="first last">
<li>-i -d[t] 可以合并为-id[t]。d标志位表示创建后台容器。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>退出容器：执行exit命令。</dt>
<dd><ul class="first last">
<li>退出后容器将关闭</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -it --name<span class="o">=</span>web_server nginx:v3 /bin/bash

root@3c7e127ff4ae:/# ls
bin   dev  home  lib64  mnt  proc  run   srv  tmp  var
boot  etc  lib   media  opt  root  sbin  sys  usr

$ docker run -id --name<span class="o">=</span>app_server  nginx:v3  /bin/bash

4b19f6042d9739a3dba3eccd93d4404259883ecf0f6402232124357914835b30
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">进入</p>
<blockquote>
<div><div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">docker exec -it [容器名称] /bin/bash</p>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker <span class="nb">exec</span> -it app_server /bin/bash
root@4b19f6042d97:/#
$ <span class="nb">exit</span>
$ docker ps
CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES
4b19f6042d97        nginx:v3            <span class="s2">&quot;/bin/bash&quot;</span>         <span class="m">4</span> minutes ago       Up <span class="m">4</span> minutes        <span class="m">80</span>/tcp              app_server
</pre></div>
</div>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>启动</dt>
<dd><ul class="first last simple">
<li>docker start [app_server]</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>停止</dt>
<dd><ul class="first last simple">
<li>docker stop [app_server]</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>删除</dt>
<dd><ul class="first simple">
<li><dl class="first docutils">
<dt>docker rm app_server</dt>
<dd><ul class="first last">
<li>删除单个</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>docker rm `docker ps -aq`</dt>
<dd><ul class="first last">
<li>删除所有</li>
<li>q标志表示只列出容器ID，不列出其他信息。</li>
</ul>
</dd>
</dl>
</li>
</ul>
<div class="last admonition note">
<p class="first admonition-title">注解</p>
<p class="last">`符号是键盘table上方的键位</p>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>查看容器信息</dt>
<dd><ul class="first last simple">
<li>docker inspect [app_server]</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
</div>
<div class="section" id="id15">
<h2>1.6. Docker容器的数据卷<a class="headerlink" href="#id15" title="永久链接至标题">¶</a></h2>
<div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">主要探讨容器中的应用数据管理相关话题。如数据如何保存、外部如何使用数据等。</p>
</div>
<div class="section" id="id16">
<h3>1.6.1. 概念及作用<a class="headerlink" href="#id16" title="永久链接至标题">¶</a></h3>
<div class="section" id="id17">
<h4>1.6.1.1. 概念<a class="headerlink" href="#id17" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li>数据卷是宿主机中的一个目录或文件。</li>
<li>容器目录（文件）和数据卷目录（文件）绑定后，双方修改会立即同步。</li>
<li>一个数据卷可被多个容器挂载；一个容器也可挂载多个数据卷。</li>
</ol>
</div></blockquote>
</div>
<div class="section" id="id18">
<h4>1.6.1.2. 作用<a class="headerlink" href="#id18" title="永久链接至标题">¶</a></h4>
<blockquote>
<div><ol class="arabic simple">
<li>可持久化保存容器数据。</li>
<li>实现外部机器和容器间接通信。</li>
<li>容器之间进行数据交换。</li>
</ol>
</div></blockquote>
</div>
</div>
<div class="section" id="id19">
<h3>1.6.2. 配置数据卷<a class="headerlink" href="#id19" title="永久链接至标题">¶</a></h3>
<div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<ol class="arabic simple">
<li><dl class="first docutils">
<dt>创建容器时，使用-v参数</dt>
<dd><ul class="first last">
<li>docker run …… -v 宿主机目录（文件）:容器内部目录（文件）</li>
<li>目录不存在时，会自动创建。</li>
<li>目录是绝对路径。</li>
<li>可以挂载多个数据卷。</li>
</ul>
</dd>
</dl>
</li>
</ol>
<a class="last reference internal image-reference" href="../../_images/docker数据卷.png"><img alt="../../_images/docker数据卷.png" src="../../_images/docker数据卷.png" style="width: 700px;" /></a>
</div>
<ol class="arabic">
<li><p class="first">挂载单个数据卷：将本机的host_data目录挂载到容器的container_data下</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -it --name<span class="o">=</span>c1 -v /Users/hanghangli/Desktop/host_data:/root/container_data  nginx:v3
<span class="c1"># 进入容器</span>
<span class="nv">$docker</span> <span class="nb">exec</span> -it c1 /bin/bash
<span class="nv">$root</span>@2c651df94731:/# <span class="nb">cd</span> root/
<span class="c1"># 可以看到在容器内已经有了挂载目录</span>
<span class="nv">$root</span>@2c651df94731:~# ls
container_data
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">一个容器挂载多个数据卷：将本机的data_1.txt、data_2.txt文件挂载到容器的container_data_1.txt、container_data_2.txt</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -it --name<span class="o">=</span>c2 <span class="se">\</span>
-v /Users/hanghangli/Desktop/data_1.txt:/root/container_data_1.txt <span class="se">\</span>
-v /Users/hanghangli/Desktop/data_1.txt:/root/container_data_2.txt <span class="se">\</span>
nginx:v3
<span class="c1"># 进入容器</span>
$ docker <span class="nb">exec</span> -it c2 /bin/bash
$ ls root/
<span class="c1"># 可以看到在容器内已经有了挂载的两个文件</span>
container_data_1.txt  container_data_2.txt
$ cat container_data_1.txt
</pre></div>
</div>
</div></blockquote>
</li>
<li><p class="first">多个容器挂载一个数据卷。c3与c4容器挂载一个config.ini.txt文件</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -it --name<span class="o">=</span>c3 <span class="se">\</span>
-v /Users/hanghangli/Desktop/config.ini.txt:/root/container_config.ini.txt.txt <span class="se">\</span>
nginx:v3
$ docker run -it --name<span class="o">=</span>c4 <span class="se">\</span>
-v /Users/hanghangli/Desktop/config.ini.txt:/root/container_config.ini.txt <span class="se">\</span>
nginx:v3
<span class="c1"># 现在修改一下config.ini.txt文件内容并查看下容器的数据卷是否同步了修改。</span>
<span class="c1"># 先看下c3容器</span>
$ docker <span class="nb">exec</span> -it c3 /bin/bash
$ root@d8b63fe631cb:~# ls
    container_config.ini.txt.txt
$ root@d8b63fe631cb:~# cat container_config.ini.txt.txt
    我修改了宿主机的配置文件。
$ root@d8b63fe631cb:~# <span class="nb">exit</span>
<span class="c1"># 再看下c4容器</span>
$ docker <span class="nb">exec</span> -it c4 /bin/bash
$ root@cfb85d4cb3c4:/# cat root/container_config.ini.txt
    我修改了宿主机的配置文件。
</pre></div>
</div>
</div></blockquote>
</li>
</ol>
</div>
<div class="section" id="id20">
<h3>1.6.3. 配置 数据卷容器<a class="headerlink" href="#id20" title="永久链接至标题">¶</a></h3>
<div class="admonition tip">
<p class="first admonition-title">小技巧</p>
<ul class="simple">
<li>使用场景：的时，并不想指定挂载的宿主机的目录，只想实现容器与容器之间的数据共享。</li>
<li>上面的方法是给每个容器挂载本地数据卷，这样在容器比较少的情况下是一个好方法。但当我们的容器很多且都有挂载数据卷的需求，上面的方式就显得不够高效和友好。</li>
<li>我们可以考虑专门做个挂载数据卷的容器，让它专门负责数据卷挂载，其他容器直接挂载这个数据卷容器即可。这样就增加了可扩展行和可维护性！</li>
</ul>
<p>⚠️无论数据卷容器停止还是删除都不会影响其他容器对于数据卷的使用！</p>
<ul class="simple">
<li>容器之间共享一些持续更新的数据，最简单的方式是使用数据卷容器</li>
</ul>
<a class="reference internal image-reference" href="../../_images/docker数据卷容器.png"><img alt="../../_images/docker数据卷容器.png" src="../../_images/docker数据卷容器.png" style="width: 700px;" /></a>
<ul class="last simple">
<li><dl class="first docutils">
<dt>创建数据卷容器test_1</dt>
<dd><ol class="first last arabic">
<li>docker run -it –name=test_1 -v /volume image:tag /bin/bash</li>
</ol>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>挂载数据卷test_1给容器test_2、test_3</dt>
<dd><ol class="first last arabic" start="2">
<li>docker run -it –name=test_2 –volumes-from test_1 image:tag /bin/bash</li>
<li>docker run -it –name=test_3 –volumes-from test_1 image:tag /bin/bash</li>
</ol>
</dd>
</dl>
</li>
</ul>
</div>
<div class="highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 创建数据卷容器 会自动分配一个目录</span>
$ docker run -it --name<span class="o">=</span>test_1 -v /volume nginx  /bin/bash

<span class="c1"># 挂载test_1到test_2</span>
$ docker run -it --name<span class="o">=</span>test_2 --volumes-from test_1 nginx  /bin/bash
<span class="c1"># 挂载test_1到test_3</span>
$ docker run -it --name<span class="o">=</span>test_3 --volumes-from test_1 nginx  /bin/bash

<span class="c1"># 我们可以测试数据同步情况，我在test_1容器/volume目录新建一个config.ini，看下test_2和test_3下是否会出现呢？</span>
$ root@75fb3393fb19:/volume# <span class="nb">echo</span> <span class="s2">&quot;hello,Docker&quot;</span> &gt;&gt; config.ini
<span class="c1"># 在test_2下的volume目录中查看写入内容</span>
$ docker <span class="nb">exec</span> -it test_2 /bin/bash
$ root@95025edc8a00:/# cat volume/config.ini
    hello,Docker
<span class="c1"># 类似的test_3下也会出现的，自己看下吧，聪明的你看到了吗？</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id21">
<h2>1.7. Docker使用案例（应用部署实战）<a class="headerlink" href="#id21" title="永久链接至标题">¶</a></h2>
<div class="admonition note">
<p class="first admonition-title">注解</p>
<ul class="last simple">
<li>下面就进入Docker的在我们开发中的实际应用了，让我们一点点感受它带来的便利吧。加油，老铁们！</li>
<li><dl class="first docutils">
<dt>如果抽象出来部署操，可分为以下几步：</dt>
<dd><ul class="first last">
<li>搜索需要安装的软件（镜像）。如mysql的版本。</li>
<li>从仓库获取镜像。从私有或公共仓库获取。</li>
<li>创建容器。创建容器的方式可以是命令行也可以使用Dockerfile文件来build。</li>
<li>完成。</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="mysql">
<h3>1.7.1. MySQL部署<a class="headerlink" href="#mysql" title="永久链接至标题">¶</a></h3>
<ol class="arabic">
<li><dl class="first docutils">
<dt>目标</dt>
<dd><p class="first">实现在Docker中部署MySQL，并通过外部客户端操作该容器中的数据库。</p>
<div class="last admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">思考：外部如何访问容器内的数据库呢？
解决方案：引入端口映射方法。</p>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>过程</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>搜索mysql (可省略步骤）</dt>
<dd><p class="first last">docker search mysql:5.6</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>拉取mysql</dt>
<dd><p class="first last">docker pull mysql:5.6</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>创建容器</dt>
<dd><div class="first highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在本地创建一个数据库目录并进入。</span>
$ mkdir mysql
$ <span class="nb">cd</span> ~/mysql
<span class="c1"># $PWD表示当前目录路径</span>
$ docker run -id <span class="se">\</span>
-p <span class="m">3307</span>:3306 <span class="se">\</span>
--name mysql_container <span class="se">\</span>
-v <span class="nv">$PWD</span>/conf:/etc/mysql/conf.d <span class="se">\</span>
-v <span class="nv">$PWD</span>/logs:/logs <span class="se">\</span>
-v <span class="nv">$PWD</span>/data:/var/lib/mysql <span class="se">\</span>
-e <span class="nv">MYSQL_ROOT_PASSWORD</span><span class="o">=</span>pass <span class="se">\</span>
mysql:5.6
e39f78f46f1585225bab52499ad4d81032bc35d52972341503f47bdd1992d277
$ docker ps
CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
e39f78f46f15        mysql:5.6           <span class="s2">&quot;docker-entrypoint.sh&quot;</span>   <span class="m">7</span> seconds ago       Up <span class="m">5</span> seconds        <span class="m">0</span>.0.0.0:3307-&gt;3306/tcp   mysql_container
</pre></div>
</div>
<ul class="last simple">
<li><dl class="first docutils">
<dt>参数说明</dt>
<dd><ul class="first last">
<li>-p 3307:3306  端口映射。将容器mysql的3306映射到主机的3307。</li>
<li>-v $PWD/conf:/etc/mysql/conf.d  挂载数据库配置数据卷。将本地（刚才创建的mysql目录）当前目录的conf挂载到容器/etc/mysql/conf.d</li>
<li>-v $PWD/logs:/logs 挂载日志数据卷。将本地当前目录的logs挂载到容器/logs。</li>
<li>-v $PWD/<a class="reference external" href="data:/var/lib/mysql">data:/var/lib/mysql</a> 挂载数据数据卷。将本地当前目录的data挂载到容器/var/lib/mysql</li>
<li>-e MYSQL_ROOT_PASSWORD=pass 初始化root用户的密码</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>操作容器中的mysql</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 进入容器</span>
$ docker <span class="nb">exec</span> -it mysql_container /bin/bash
<span class="c1"># 在容器中登录mysql</span>
root@e39f78f46f15:/#  mysql -uroot -ppass
mysql&gt;
<span class="c1"># 下面我们可以在本地用任意客户端登录mysql，注意端口填写3307就行。登录后可以常见一个数据库和表，再进入容器就会看到刚才创建的表了。</span>
<span class="c1"># 到此，mysql的容器化就完成啦。</span>

<span class="c1"># 其他命令：mysql容器端口的映射信息</span>
$ docker port mysql_container <span class="m">3306</span>
    <span class="m">0</span>.0.0.0:3307
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="tomcat">
<h3>1.7.2. Tomcat部署<a class="headerlink" href="#tomcat" title="永久链接至标题">¶</a></h3>
<ol class="arabic">
<li><dl class="first docutils">
<dt>目标</dt>
<dd><ul class="first last simple">
<li>实现在Docker中部署Tomcat，并通过本地浏览器访问网页，确定服务器是否正常工作。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>创建过程</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>拉取镜像</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在本地创建一个数据库目录并进入。</span>
$ mkdir tomcat
$ <span class="nb">cd</span> tomcat
<span class="c1"># $PWD表示当前目录路径</span>
$ docker pull tomcat
Using default tag: latest
latest: Pulling from library/tomcat
50e431f79093: Pull <span class="nb">complete</span>
dd8c6d374ea5: Pull <span class="nb">complete</span>
c85513200d84: Pull <span class="nb">complete</span>
55769680e827: Pull <span class="nb">complete</span>
e27ce2095ec2: Pull <span class="nb">complete</span>
5943eea6cb7c: Pull <span class="nb">complete</span>
3ed8ceae72a6: Pull <span class="nb">complete</span>
91d1e510d72b: Pull <span class="nb">complete</span>
98ce65c663bc: Pull <span class="nb">complete</span>
27d4ac9d012a: Pull <span class="nb">complete</span>
Digest: sha256:2c90303e910d7d5323935b6dc4f8ba59cc1ec99cf1b71fd6ca5158835cffdc9c
Status: Downloaded newer image <span class="k">for</span> tomcat:latest
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>创建Tomcat容器</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 在本地创建一个数据库目录并进入。</span>
$ mkdir tomcat
$ <span class="nb">cd</span> tomcat
<span class="c1"># $PWD表示当前目录路径</span>

$ docker run -id --name<span class="o">=</span>tomcat <span class="se">\</span>
    -p <span class="m">8080</span>:8080 <span class="se">\</span>
    -v <span class="nv">$PWD</span>:/usr/local/tomcat/webapps <span class="se">\</span>
    tomcat

    5949c2cfd5fe1d4d3395996d22804d08e7e5debc8255d032fd12ab1f1d54be4f
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>使用容器</dt>
<dd><ul class="first last simple">
<li><dl class="first docutils">
<dt>在本地机器创建的tomcat目录下</dt>
<dd><ul class="first last">
<li>mkdir my_app</li>
<li>echo ‘&lt;h1&gt;hello,Docker!&lt;/h1&gt;’ &gt; my_app/index.html</li>
<li>访问：<a class="reference external" href="http://0.0.0.0:8080/my_app/index.html">http://0.0.0.0:8080/my_app/index.html</a></li>
<li>大功告成！</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
<div class="section" id="nginx">
<h3>1.7.3. Nginx部署<a class="headerlink" href="#nginx" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>拉取镜像</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker pull nginx
Using default tag: latest
latest: Pulling from library/nginx
68ced04f60ab: Pull <span class="nb">complete</span>
28252775b295: Pull <span class="nb">complete</span>
a616aa3b0bf2: Pull <span class="nb">complete</span>
Digest: sha256:2539d4344dd18e1df02be842ffc435f8e1f699cfc55516e2cf2cb16b7a9aea0b
Status: Downloaded newer image <span class="k">for</span> nginx:latest
</pre></div>
</div>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>创建容器并测试</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span><span class="c1"># 准备工作</span>
$ mkdir nginx
$ <span class="nb">cd</span> nginx
$ mkdir conf html logs
$ vim conf/nginx.conf
    <span class="c1">#user  nobody;</span>
    worker_processes  <span class="m">1</span><span class="p">;</span>

    <span class="c1">#error_log  logs/error.log;</span>
    <span class="c1">#error_log  logs/error.log  notice;</span>
    <span class="c1">#error_log  logs/error.log  info;</span>

    <span class="c1">#pid        logs/nginx.pid;</span>

    events <span class="o">{</span>
        worker_connections  <span class="m">1024</span><span class="p">;</span>
    <span class="o">}</span>

    http <span class="o">{</span>
        include       mime.types<span class="p">;</span>
        default_type  application/octet-stream<span class="p">;</span>

        <span class="c1">#log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span>
        <span class="c1"># &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span>
        <span class="c1"># &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span>
        <span class="c1">#access_log  logs/access.log  main;</span>
        sendfile        on<span class="p">;</span>
        <span class="c1">#tcp_nopush     on;</span>
        <span class="c1">#keepalive_timeout  0;</span>
        keepalive_timeout  <span class="m">65</span><span class="p">;</span>
        <span class="c1">#gzip  on;</span>
    include /etc/nginx/conf.d/*.conf<span class="p">;</span>
    <span class="o">}</span>
$ <span class="nb">echo</span> <span class="s1">&#39;&lt;h1&gt;Hello, Nginx. &lt;/h1&gt;&#39;</span> &gt; html/index.html
$ docker run -id --name<span class="o">=</span>my_nginx <span class="se">\</span>
    -p <span class="m">80</span>:80 <span class="se">\</span>
    -v <span class="nv">$PWD</span>/conf/nginx.conf:/etc/nginx/nginx.conf <span class="se">\</span>
    -v <span class="nv">$PWD</span>/logs:/var/log/nginx <span class="se">\</span>
    -v <span class="nv">$PWD</span>/html:/usr/share/nginx/html <span class="se">\</span>
    nginx
$ 访问0.0.0.0
    Hello, Nginx.
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="redis-key-value">
<h3>1.7.4. Redis部署（一个key-value存储系统）<a class="headerlink" href="#redis-key-value" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><ul>
<li><dl class="first docutils">
<dt>目标</dt>
<dd><ul class="first last simple">
<li>创建Redis容器，并使用本地机器进行访问。</li>
</ul>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>拉取镜像</dt>
<dd><ul class="first last simple">
<li>docker pull reids</li>
</ul>
</dd>
</dl>
</li>
<li><p class="first">创建容器</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker run -id --name<span class="o">=</span>my_redis <span class="se">\</span>
-p <span class="m">6379</span>:6379 <span class="se">\</span>
redis
<span class="c1"># 内部先测试下</span>
$ docker <span class="nb">exec</span> -it my_redis /bin/bash
$ root@679f5de7ab12:/data# redis-cli
$ <span class="m">27</span>.0.0.1:6379&gt; <span class="nb">set</span> name <span class="s1">&#39;test&#39;</span>
    OK
$ <span class="m">127</span>.0.0.1:6379&gt; get name
    <span class="s2">&quot;test&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>外部连接测试</dt>
<dd><ul class="first last">
<li><dl class="first docutils">
<dt>mac系统下安装Redis</dt>
<dd><ul class="first simple">
<li>brew install redis</li>
</ul>
<div class="last admonition tip">
<p class="first admonition-title">小技巧</p>
<p class="last">如果下载太慢可更换brew的仓库源，可参考：<a class="reference external" href="https://www.jianshu.com/p/8a2ac505ff3e">https://www.jianshu.com/p/8a2ac505ff3e</a></p>
</div>
</dd>
</dl>
</li>
<li><p class="first">连接测试</p>
<blockquote>
<div><div class="highlight-bash notranslate"><div class="highlight"><pre><span></span>$ redis-cli -h <span class="m">0</span>.0.0.0 -p <span class="m">6379</span>
$ <span class="m">0</span>.0.0.0:6379&gt; get name
    <span class="s2">&quot;test&quot;</span>
</pre></div>
</div>
</div></blockquote>
</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="dockerfile">
<h2>1.8. 使用Dockerfile制作镜像<a class="headerlink" href="#dockerfile" title="永久链接至标题">¶</a></h2>
<div class="section" id="id22">
<h3>1.8.1. 镜像原理<a class="headerlink" href="#id22" title="永久链接至标题">¶</a></h3>
<ul>
<li><p class="first">镜像是由特殊的文件系统叠加而成。</p>
</li>
<li><p class="first">采用分层的文件系统，通过在只读文件（镜像）上增加可读写层（容器）的形式来改变镜像。</p>
</li>
<li><dl class="first docutils">
<dt>Docker镜像结构图</dt>
<dd><a class="first reference internal image-reference" href="../../_images/Docker镜像结构.png"><img alt="../../_images/Docker镜像结构.png" src="../../_images/Docker镜像结构.png" style="width: 600px;" /></a>
<ul class="last simple">
<li><dl class="first docutils">
<dt>bootfs。启动文件系统镜像，复用了宿主机的文件系统。</dt>
<dd><ul class="first last">
<li>这也就解释了我们单独下载Ubuntu可能就是好几个G大小，但是利用docker就是几百兆的大小。</li>
</ul>
</dd>
</dl>
</li>
<li>rootfs。根文件系统，也成为根镜像，一般就是一个操作系统。</li>
<li><dl class="first docutils">
<dt>Image-1、Image-2。这些就是我们用户的镜像，可以不断叠加，下层为父镜像。</dt>
<dd><ul class="first last">
<li>这也就解释了如果单独下载MySQL可能也就几十兆的大小，但使用docker就要几百兆的大小，反而变大了。究其原因，就是只读文件存在依赖的关系，叠加后变大了。</li>
</ul>
</dd>
</dl>
</li>
<li>可读写文件。这一层就是容器了，当我们基于镜像进行容器启动时，就会在最顶层加载一个可读写的文件系统作为容器。</li>
<li>修改完后就可以提交新的镜像(制作一个新镜像）了。</li>
</ul>
</dd>
</dl>
</li>
<li></li>
<li><p class="first">创建新的镜像本质上也就是对已有的镜像文件集合进行增、删、改的操作。</p>
</li>
<li><p class="first">这种叠加的方式有利于实现镜像共享、增加可扩展性、减少磁盘空间使用。</p>
</li>
</ul>
</div>
<div class="section" id="id23">
<h3>1.8.2. Dockerfile的概念和作用<a class="headerlink" href="#id23" title="永久链接至标题">¶</a></h3>
<div class="section" id="id24">
<h4>1.8.2.1. 镜像制作方法<a class="headerlink" href="#id24" title="永久链接至标题">¶</a></h4>
<ol class="arabic">
<li><p class="first">容器转镜像（不常用）</p>
<blockquote>
<div><div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">commit</span> <span class="p">[</span><span class="nb">id</span><span class="p">]</span> <span class="p">[</span><span class="n">Image</span><span class="o">-</span><span class="n">name</span><span class="p">]:[</span><span class="n">tag</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">save</span> <span class="o">-</span><span class="n">o</span> <span class="p">[</span><span class="n">压缩文件名称</span><span class="p">]</span> <span class="p">[</span><span class="n">Image</span><span class="o">-</span><span class="n">name</span><span class="p">]:[</span><span class="n">tag</span><span class="p">]</span>
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">docker</span> <span class="n">load</span> <span class="o">-</span><span class="n">i</span> <span class="p">[</span><span class="n">压缩文件名称</span><span class="p">]</span>
</pre></div>
</div>
<div class="admonition attention">
<p class="first admonition-title">注意</p>
<p class="last">若原有镜像含有挂载文件，则commit时不会将其挂载到新制作的镜像。</p>
</div>
<ul>
<li><dl class="first docutils">
<dt>操作步骤</dt>
<dd><div class="first last highlight-bash notranslate"><div class="highlight"><pre><span></span>$ docker ps -a

CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS                   PORTS                    NAMES
679f5de7ab12        redis               <span class="s2">&quot;docker-entrypoint.sh&quot;</span>   <span class="m">12</span> hours ago        Up <span class="m">2</span> hours               <span class="m">0</span>.0.0.0:6379-&gt;6379/tcp   my_redis

<span class="c1"># 制作一个Redis镜像名为make_redis</span>
$ docker commit 679f5de7 make_redis

sha256:c5f603178b0cc95aeb04d3e674060d1268541d361748852d73d7eba652f0c6d3
<span class="c1"># 查看镜像</span>
$ docker images

REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
make_redis          latest              c5f603178b0c        <span class="m">8</span> hours ago         <span class="m">98</span>.21 MB
redis               latest              f0453552d7f2        <span class="m">32</span> hours ago        <span class="m">98</span>.21 MB
<span class="c1"># 打包镜像</span>
$ docker save -o make-redis.tar make_redis
<span class="c1"># 为了还原镜像，我们先删除存在的</span>
$ docker rmi c5f6031
Untagged: make_redis:latest
Deleted: sha256:c5f603178b0cc95aeb04d3e674060d1268541d361748852d73d7eba652f0c6d3
Deleted: sha256:88106bcdc3c35ca6ea7bdb8e7dd06d91c921a328587a0f72b87628ffea654945
<span class="c1"># 加载制作的新镜像</span>
$ docker load -i make-redis.tar
    936d71f61caa: Loading layer <span class="m">3</span>.584 kB/3.584 kB
    Loaded image: make_redis:latest
<span class="c1"># 查看是否成功还原</span>
$ docker images
    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
    make_redis          latest              c5f603178b0c        <span class="m">8</span> hours ago         <span class="m">98</span>.21 MB
    redis               latest              f0453552d7f2        <span class="m">32</span> hours ago        <span class="m">98</span>.21 MB
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>Dockerfile（常用方法）</dt>
<dd><ul class="first last simple">
<li>Dockerfile是一个文本文件，包含了一行行的指令。</li>
<li>不一定叫Dockerfile名称，可根据实际需求来。如nginx_dockerfile</li>
<li>每一行指令构建一层镜像，基于基础镜像，最终构建出一个新的镜像。</li>
<li><dl class="first docutils">
<dt>Dockerfile关键字，可参考：<a class="reference external" href="https://docs.docker.com/develop/develop-images/dockerfile_best-practices/">https://docs.docker.com/develop/develop-images/dockerfile_best-practices/</a></dt>
<dd><ul class="first last">
<li>FROM：父镜像</li>
<li>RUN：执行命令，[“command-1”, “command-2”]</li>
<li>CMD: 容器启动命令</li>
<li>COPY：复制文件</li>
<li>WORKDIR：工作目录。指定容器内的工作目录</li>
<li>ADD：添加文件</li>
</ul>
</dd>
</dl>
</li>
</ul>
</dd>
</dl>
</li>
</ol>
</div>
</div>
<div class="section" id="id25">
<h3>1.8.3. 案例<a class="headerlink" href="#id25" title="永久链接至标题">¶</a></h3>
<div class="section" id="id26">
<h4>1.8.3.1. 案例一<a class="headerlink" href="#id26" title="永久链接至标题">¶</a></h4>
<ul>
<li><dl class="first docutils">
<dt>任务</dt>
<dd><dl class="first last docutils">
<dt>制作一个centos7镜像。保证：</dt>
<dd><ul class="first last simple">
<li>默认登录路径为/usr;</li>
<li>可以使用vim</li>
</ul>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>步骤</dt>
<dd><div class="first last highlight-default notranslate"><div class="highlight"><pre><span></span>$ docker pull centos:7
$ docker run -it --name=c1 centos:7
$ vim Dockerfile
    # 定义基础镜像
    FROM centos:7
    # 作者信息
    MAINTAINER Mason
    # 执行操作
    RUN yum install -y vim
    # 设置工作目录
    WORKDIR /usr
    # 设置启动命令
    CMD [&quot;/bin/bash&quot;]
# . 表示的是当前目录，不要忘记写了
$ docker build -f Dockerfile -t test_centos:1 .
    Sending build context to Docker daemon 222.6 MB
    Step 1 : FROM centos:7
    ---&gt; 5e35e350aded
    Step 2 : MAINTAINER Mason
    ---&gt; Using cache
    ---&gt; efe73e688fd0
    Step 3 : RUN yum install -y vim
    ---&gt; Using cache
    ---&gt; d79eb09c16dc
    Step 4 : WORKDIR /usr
    ---&gt; Using cache
    ---&gt; 0da2b1bca082
    Step 5 : CMD /bin/bash
    ---&gt; Running in 697bd23b374a
    ---&gt; a71548cf9f8e
$ docker run -it --name c2 test_centos:1
$ [root@aa24050fdab5 usr]# vim test.txt

# 完成所有任务
</pre></div>
</div>
</dd>
</dl>
</li>
</ul>
</div>
<div class="section" id="id27">
<h4>1.8.3.2. 案例二<a class="headerlink" href="#id27" title="永久链接至标题">¶</a></h4>
<ul class="simple">
<li><dl class="first docutils">
<dt>任务</dt>
<dd>定义Dockerfile，发布一个SpringBoot项目</dd>
</dl>
</li>
<li>步骤</li>
</ul>
</div>
</div>
</div>
<div class="section" id="docker-compose">
<h2>1.9. docker-compose（服务编排技术）<a class="headerlink" href="#docker-compose" title="永久链接至标题">¶</a></h2>
<div class="section" id="id28">
<h3>1.9.1. 服务编排概念<a class="headerlink" href="#id28" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>docker-compose是一个工具。能够编排多容器分布式部署，以指令集的形式管理容器化应用的开发周期，如构建、启动、停止。</li>
<li><dl class="first docutils">
<dt>基本过程</dt>
<dd><ul class="first last">
<li>利用Dockerfile定义运行环境镜像。</li>
<li>使用docker-compose.yml定义组成应用的各服务。</li>
<li>运行docker-compose up 启动应用。</li>
</ul>
</dd>
</dl>
</li>
</ul>
</div></blockquote>
</div>
<div class="section" id="id29">
<h3>1.9.2. 实例<a class="headerlink" href="#id29" title="永久链接至标题">¶</a></h3>
<blockquote>
<div><ul class="simple">
<li>安装</li>
<li>过程</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="id30">
<h2>1.10. 搭建私有仓库<a class="headerlink" href="#id30" title="永久链接至标题">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="k8s.html" class="btn btn-neutral float-right" title="2. Kubernetes（K8S）" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="../数据库系列/mysql.html" class="btn btn-neutral float-left" title="1. MySQL" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, LiHangHang

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>